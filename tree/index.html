<!DOCTYPE html>
<html>
<head>
    <title>Organic L-System Forest</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #d0e7f0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="treeCanvas"></canvas>
    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');

        const trees = [];
        const shrubs = [];
        const weeds = [];
        let frame = 0;

        // --- GLOBAL ANIMATION CONSTANTS ---
        const MIN_TREES = 4;
        const MAX_TREES = 6;
        const GLOBAL_WIND_STRENGTH = 1.0;
        const SHRUB_WIND_MULTIPLIER = 2.0;
        const WEED_WIND_MULTIPLIER = 4.0;

        // --- PRESET DEFINITIONS ---
        const PASTEL_FLOWER_COLORS = ['#ffadad', '#ffd6a5', '#fdffb6', '#caffbf', '#9bf6ff', '#a0c4ff', '#bdb2ff', '#ffc6ff'];

        const TREE_PRESETS = [
            {
                type: 'leafy', name: 'classic',
                rules: {
                    'X': [ // Significantly different structural variations
                        'F+[[XL]-XL]-F[-FXL]+XL',  // Original complex
                        'F[+F[L]X][-F[L]X]FXL',    // Forking structure
                        'F[+XL]F[-XL][X]L'         // Strong trunk with a top tuft
                    ],
                    'F': 'FF'
                },
                iterations: 5, angle: 25, initialThickness: 8, barkColor: '#5a3a29', leafColor: '#2a9d8f', leafShape: 'classic'
            },
            {
                type: 'leafy', name: 'upward',
                rules: {
                    'X': [
                        'F[+XL]F[-XL]+X',         // Original upward
                        'FF[+X[L]][-X[L]]',       // Taller, pine-like
                        'F[+X[L]][-X[L]]+FXL'      // Bushier at the tips
                    ],
                    'F': 'FF'
                },
                iterations: 5, angle: 22, initialThickness: 10, barkColor: '#6f4533', leafColor: '#e76f51', leafShape: 'maple'
            },
            {
                type: 'leafy', name: 'weeping',
                rules: {
                    'X': [
                        'F[--XL]F[++XL]FXL',       // Original weeping
                        'F[--F[L]X]F[++F[L]X]FX',  // More pronounced droop
                        'F[---XL][++XL]FXL'        // Asymmetric weeping
                    ],
                    'F': 'FF'
                },
                iterations: 5, angle: 18, initialThickness: 7, barkColor: '#8a7e6c', leafColor: '#93a35a', leafShape: 'willow'
            },
            {
                type: 'leafy', name: 'broadleaf',
                rules: {
                    'X': [
                        'F[+XL][-XL]F[+XL]X',     // Original wide
                        'FF[-[XL]+[XL]]F[+X[L]]', // Stronger trunk, wide crown
                        'F[+F[-XL]][-F[+XL]]FXL'   // Gnarled, wide branches
                    ],
                    'F': 'FF'
                },
                iterations: 5, angle: 30, initialThickness: 9, barkColor: '#7a6e60', leafColor: '#4f7553', leafShape: 'broad'
            }
        ];

        const SHRUB_PRESETS = [
            { type: 'leafy', rules: { 'X': 'F-[[XL]+XL]+F[+FXL]-XL', 'F': 'FF' }, iterations: 4, angle: 30, initialThickness: 4, barkColor: '#4c956c', leafColor: '#fefee3', leafShape: 'oval' },
            { type: 'leafy', rules: { 'X': 'F[+XL][-XL]FXL', 'F': 'FF' }, iterations: 4, angle: 25, initialThickness: 3, barkColor: '#5fa8d3', leafColor: '#f2f2f2', leafShape: 'willow' },
            { type: 'flower', flowerShape: 'petal', rules: { 'X': 'F[+F-XO][-F+XO]XO', 'F': 'FF' }, iterations: 4, angle: 28, initialThickness: 5, barkColor: '#6a994e' },
            { type: 'flower', flowerShape: 'bell', rules: { 'X': 'F[+FXO][-F-X]FX', 'F': 'FF' }, iterations: 5, angle: 25, initialThickness: 3, barkColor: '#7b8c74' }
        ];

        const WEED_PRESETS = [
            { type: 'weed', rules: { 'X': 'F[+X]F[-X]+X', 'F': 'FF' }, iterations: 4, angle: 20, initialThickness: 2, barkColor: '#6a994e' },
            { type: 'weed', rules: { 'X': 'F[+X][-X]FX', 'F': 'FF' }, iterations: 4, angle: 25.7, initialThickness: 2, barkColor: '#4c956c' },
            { type: 'weed', rules: { 'X': 'F-[[X]+X]+F[+FX]-X', 'F': 'FF' }, iterations: 3, angle: 22, initialThickness: 1.5, barkColor: '#588157' },
            { type: 'weed', rules: { 'X': 'F[-F[+X]]F[+F[-X]]X', 'F': 'F' }, iterations: 5, angle: 15, initialThickness: 1, barkColor: '#73a942' }
        ];

        function generateLSystem(iterations, rules) {
            let currentString = 'X';
            for (let i = 0; i < iterations; i++) {
                let nextString = '';
                for (const char of currentString) {
                    const rule = rules[char];
                    if (Array.isArray(rule)) {
                        nextString += rule[Math.floor(Math.random() * rule.length)];
                    } else {
                        nextString += rule || char;
                    }
                }
                currentString = nextString;
            }
            return currentString;
        }

        function calculateMaxHeight(lSystemString, length, angle) {
            let state = { y: 0, angle: -90 * (Math.PI / 180) };
            let minY = 0;
            const stack = [];
            for (const command of lSystemString) {
                switch (command) {
                    case 'F': state.y += length * Math.sin(state.angle); minY = Math.min(minY, state.y); break;
                    case '+': state.angle += angle * (Math.PI / 180); break;
                    case '-': state.angle -= angle * (Math.PI / 180); break;
                    case '[': stack.push({ ...state }); break;
                    case ']': state = stack.pop(); break;
                }
            }
            return Math.abs(minY);
        }

        function setupPlantData(preset, plantType) {
            let length;
            if (plantType === 'tree') length = 5;
            else if (plantType === 'shrub') length = 4;
            else length = 3;

            const lindenmayerString = generateLSystem(preset.iterations, preset.rules);
            const barkColors = [];
            const baseHex = parseInt(preset.barkColor.slice(1), 16);
            let r_base = (baseHex >> 16) & 0xff, g_base = (baseHex >> 8) & 0xff, b_base = baseHex & 0xff;
            for (const char of lindenmayerString) {
                if (char === 'F') {
                    const r = r_base + Math.round((Math.random() - 0.5) * 15), g = g_base + Math.round((Math.random() - 0.5) * 15), b = b_base + Math.round((Math.random() - 0.5) * 15);
                    barkColors.push(`rgb(${r},${g},${b})`);
                }
            }
            const unscaledHeight = calculateMaxHeight(lindenmayerString, length, preset.angle);
            return { ...preset, plantType, lindenmayerString, length, unscaledHeight, barkColors, stack: [] };
        }

        function preRenderPlant(plantData) {
            const offscreenCanvas = document.createElement('canvas');
            const oCtx = offscreenCanvas.getContext('2d');
            const renderSize = plantData.plantType === 'tree' ? canvas.height * 2 : canvas.height * 1.5;
            offscreenCanvas.width = renderSize;
            offscreenCanvas.height = renderSize;

            oCtx.save();
            oCtx.translate(renderSize / 2, renderSize);
            oCtx.scale(plantData.scale, plantData.scale);
            oCtx.lineCap = 'round';
            oCtx.lineWidth = plantData.initialThickness;

            let barkColorIndex = 0;
            for (const command of plantData.lindenmayerString) {
                switch (command) {
                    case 'F':
                        oCtx.strokeStyle = plantData.barkColors[barkColorIndex++];
                        oCtx.beginPath(); oCtx.moveTo(0, 0); oCtx.lineTo(0, -plantData.length); oCtx.stroke();
                        oCtx.translate(0, -plantData.length);
                        oCtx.lineWidth *= 0.98;
                        break;
                    case 'L': drawStaticLeaf(oCtx, plantData); break;
                    case 'O': drawStaticFlower(oCtx, plantData); break;
                    case '+': oCtx.rotate((Math.PI / 180) * plantData.angle); break;
                    case '-': oCtx.rotate(-(Math.PI / 180) * plantData.angle); break;
                    case '[': plantData.stack.push({ transform: oCtx.getTransform(), lineWidth: oCtx.lineWidth }); oCtx.lineWidth *= 0.7; break;
                    case ']': const state = plantData.stack.pop(); oCtx.setTransform(state.transform); oCtx.lineWidth = state.lineWidth; break;
                }
            }
            oCtx.restore();
            plantData.preRenderedCanvas = offscreenCanvas;
            plantData.renderHeight = renderSize;
        }

        function drawPlant(plant) {
            ctx.save();
            let windMultiplier = 1.0;
            if (plant.plantType === 'shrub') windMultiplier = SHRUB_WIND_MULTIPLIER;
            if (plant.plantType === 'weed') windMultiplier = WEED_WIND_MULTIPLIER;
            const windStrength = GLOBAL_WIND_STRENGTH * windMultiplier;
            const trunkSway = Math.sin((frame / 220) + plant.x / 50) * 0.015 * windStrength;
            
            ctx.translate(plant.x, canvas.height);
            ctx.rotate(trunkSway);
            
            ctx.drawImage(plant.preRenderedCanvas, -plant.renderHeight / 2, -plant.renderHeight);
            ctx.restore();
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            frame++;
            for (const tree of trees) drawPlant(tree);
            for (const shrub of shrubs) drawPlant(shrub);
            for (const weed of weeds) drawPlant(weed);
            
            const groundHeight = 30;
            ctx.fillStyle = '#4a5742';
            ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            requestAnimationFrame(animate);
        }

        function initialize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            trees.length = 0; shrubs.length = 0; weeds.length = 0;

            const numTrees = MIN_TREES + Math.floor(Math.random() * (MAX_TREES - MIN_TREES + 1));
            const spacingTrees = canvas.width / numTrees;
            for (let i = 0; i < numTrees; i++) {
                const preset = TREE_PRESETS[Math.floor(Math.random() * TREE_PRESETS.length)];
                const plant = setupPlantData(preset, 'tree');
                const targetHeight = canvas.height * (0.85 + Math.random() * 0.15);
                plant.scale = targetHeight / plant.unscaledHeight;
                plant.x = (i * spacingTrees) + (spacingTrees / 2) + (Math.random() - 0.5) * (spacingTrees * 0.5);
                preRenderPlant(plant);
                trees.push(plant);
            }

            const numShrubs = 15; const spacingShrubs = canvas.width / numShrubs;
            for (let i = 0; i < numShrubs; i++) {
                const preset = SHRUB_PRESETS[Math.floor(Math.random() * SHRUB_PRESETS.length)];
                const plant = setupPlantData(preset, 'shrub');
                const targetHeight = canvas.height * (0.15 + Math.random() * 0.1);
                plant.scale = targetHeight / plant.unscaledHeight;
                plant.x = (i * spacingShrubs) + (spacingShrubs / 2) + (Math.random() - 0.5) * spacingShrubs;
                if (plant.type === 'flower') {
                    plant.flowerColor = PASTEL_FLOWER_COLORS[Math.floor(Math.random() * PASTEL_FLOWER_COLORS.length)];
                }
                preRenderPlant(plant);
                shrubs.push(plant);
            }

            const numWeeds = 40; const spacingWeeds = canvas.width / numWeeds;
            for (let i = 0; i < numWeeds; i++) {
                const preset = WEED_PRESETS[Math.floor(Math.random() * WEED_PRESETS.length)];
                const plant = setupPlantData(preset, 'weed');
                const targetHeight = canvas.height * (0.05 + Math.random() * 0.05);
                plant.scale = targetHeight / plant.unscaledHeight;
                plant.x = (i * spacingWeeds) + (spacingWeeds / 2) + (Math.random() - 0.5) * spacingWeeds;
                preRenderPlant(plant);
                weeds.push(plant);
            }
        }
        
        function drawStaticLeaf(oCtx, plant) {
            oCtx.fillStyle = plant.leafColor + 'aa';
            oCtx.beginPath();
            switch (plant.leafShape) {
                case 'classic': oCtx.moveTo(0, 0); oCtx.quadraticCurveTo(5, -5, 0, -15); oCtx.quadraticCurveTo(-5, -5, 0, 0); break;
                case 'maple': oCtx.moveTo(0, 0); oCtx.lineTo(2, -4); oCtx.lineTo(6, -4); oCtx.lineTo(4, -6); oCtx.lineTo(5, -10); oCtx.lineTo(0, -8); oCtx.lineTo(-5, -10); oCtx.lineTo(-4, -6); oCtx.lineTo(-6, -4); oCtx.lineTo(-2, -4); break;
                case 'willow': oCtx.scale(0.6, 1); oCtx.arc(0, -10, 5, 0, Math.PI * 2); oCtx.setTransform(oCtx.getTransform()); break;
                case 'broad': oCtx.moveTo(0, 0); oCtx.quadraticCurveTo(8, -8, 0, -20); oCtx.quadraticCurveTo(-8, -8, 0, 0); break;
                case 'oval': default: oCtx.arc(0, -5, 5, 0, Math.PI * 2); break;
            }
            oCtx.fill();
        }

        function drawStaticFlower(oCtx, plant) {
            oCtx.fillStyle = plant.flowerColor; oCtx.strokeStyle = 'rgba(0,0,0,0.1)'; oCtx.lineWidth = 0.5;
            switch (plant.flowerShape) {
                case 'bell': oCtx.beginPath(); oCtx.arc(0, 0, 4, 0, Math.PI); oCtx.lineTo(-4, 0); oCtx.lineTo(0, -6); oCtx.lineTo(4, 0); oCtx.fill(); oCtx.stroke(); break;
                case 'starburst': oCtx.beginPath(); for (let i = 0; i < 8; i++) { const angle = (Math.PI / 4) * i; const len = i % 2 === 0 ? 6 : 3; oCtx.moveTo(0, 0); oCtx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len); } oCtx.stroke(); break;
                case 'petal': default: for (let i = 0; i < 5; i++) { oCtx.beginPath(); oCtx.arc(0, -4, 2.5, 0, Math.PI * 2); oCtx.fill(); oCtx.stroke(); oCtx.rotate((Math.PI * 2) / 5); } break;
            }
        }
        
        window.addEventListener('resize', initialize);
        initialize();
        animate();
    </script>
</body>
</html>